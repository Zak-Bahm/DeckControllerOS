#!/bin/sh

set -eu

BASE_URL=""
TARGET_ROOT="/var/lib/controlleros/dev"
MANIFEST_NAME="manifest.txt"
RESTART_CMD=""
DRY_RUN=0

usage() {
	echo "Usage: $0 --base-url <http://host:port> [options]"
	echo "Options:"
	echo "  --base-url <url>       Base URL that serves manifest + payload files (required)"
	echo "  --target-root <path>   Install root on Deck (default: /var/lib/controlleros/dev)"
	echo "  --manifest <name>      Manifest filename (default: manifest.txt)"
	echo "  --restart-cmd <cmd>    Command to run after successful update"
	echo "  --dry-run              Validate downloads/hashes without installing"
	echo "  -h, --help             Show help"
}

require_cmd() {
	command -v "$1" >/dev/null 2>&1 || {
		echo "error: required command not found: $1" >&2
		exit 1
	}
}

extract_base_url_host() {
	# Strip scheme, path, and optional port.
	# Example: http://192.168.50.1:8000/path -> 192.168.50.1
	echo "$1" | awk '
		{
			s = $0
			sub(/^[a-zA-Z]+:\/\//, "", s)
			sub(/\/.*/, "", s)
			sub(/:[0-9]+$/, "", s)
			print s
		}
	'
}

is_ipv4_addr() {
	echo "$1" | awk -F. '
		NF != 4 { exit 1 }
		{
			for (i = 1; i <= 4; i++) {
				if ($i !~ /^[0-9]+$/ || $i < 0 || $i > 255) exit 1
			}
		}
		END { exit 0 }
	'
}

has_route_to_host() {
	HOST="$1"
	command -v ip >/dev/null 2>&1 || return 1
	ip route get "$HOST" >/dev/null 2>&1
}

bootstrap_min_network_to_host() {
	HOST="$1"

	if has_route_to_host "$HOST"; then
		return 0
	fi

	command -v ip >/dev/null 2>&1 || return 1

	for IFACE in $(ls /sys/class/net 2>/dev/null); do
		case "$IFACE" in
			lo|sit0) continue ;;
		esac

		ip link set "$IFACE" up >/dev/null 2>&1 || true

		# Try to obtain a lease quickly if a DHCP client is present.
		if command -v udhcpc >/dev/null 2>&1; then
			udhcpc -n -q -t 3 -T 2 -i "$IFACE" >/dev/null 2>&1 || true
		elif command -v busybox >/dev/null 2>&1; then
			busybox udhcpc -n -q -t 3 -T 2 -i "$IFACE" >/dev/null 2>&1 || true
		fi

		if has_route_to_host "$HOST"; then
			echo "Network bootstrap succeeded on interface: $IFACE"
			return 0
		fi
	done

	return 1
}

while [ "$#" -gt 0 ]; do
	case "$1" in
		--base-url)
			[ "$#" -ge 2 ] || {
				echo "error: --base-url requires a value" >&2
				usage >&2
				exit 1
			}
			BASE_URL="$2"
			shift 2
			;;
		--target-root)
			[ "$#" -ge 2 ] || {
				echo "error: --target-root requires a value" >&2
				usage >&2
				exit 1
			}
			TARGET_ROOT="$2"
			shift 2
			;;
		--manifest)
			[ "$#" -ge 2 ] || {
				echo "error: --manifest requires a value" >&2
				usage >&2
				exit 1
			}
			MANIFEST_NAME="$2"
			shift 2
			;;
		--restart-cmd)
			[ "$#" -ge 2 ] || {
				echo "error: --restart-cmd requires a value" >&2
				usage >&2
				exit 1
			}
			RESTART_CMD="$2"
			shift 2
			;;
		--dry-run)
			DRY_RUN=1
			shift
			;;
		-h|--help)
			usage
			exit 0
			;;
		*)
			echo "error: unknown argument: $1" >&2
			usage >&2
			exit 1
			;;
	esac
done

[ -n "$BASE_URL" ] || {
	echo "error: --base-url is required" >&2
	usage >&2
	exit 1
}

require_cmd wget
require_cmd sha256sum
require_cmd awk
require_cmd sed

case "$BASE_URL" in
	*/ ) BASE_URL="${BASE_URL%/}" ;;
esac

BASE_HOST="$(extract_base_url_host "$BASE_URL")"
if is_ipv4_addr "$BASE_HOST"; then
	if ! has_route_to_host "$BASE_HOST"; then
		echo "No route to $BASE_HOST; attempting minimal network bootstrap..."
		if ! bootstrap_min_network_to_host "$BASE_HOST"; then
			echo "warning: automatic network bootstrap did not establish a route to $BASE_HOST" >&2
		fi
	fi
fi

TMP_DIR="$(mktemp -d /tmp/controlleros-dev-update.XXXXXX)"
trap 'rm -rf "$TMP_DIR"' EXIT INT TERM

MANIFEST_PATH="$TMP_DIR/$MANIFEST_NAME"
MANIFEST_URL="$BASE_URL/$MANIFEST_NAME"

echo "Fetching manifest: $MANIFEST_URL"
if ! wget -q -O "$MANIFEST_PATH" "$MANIFEST_URL"; then
	if is_ipv4_addr "$BASE_HOST"; then
		echo "Initial manifest fetch failed; retrying after network bootstrap..."
		bootstrap_min_network_to_host "$BASE_HOST" || true
		wget -q -O "$MANIFEST_PATH" "$MANIFEST_URL"
	else
		exit 1
	fi
fi

if [ "$DRY_RUN" -eq 0 ]; then
	mkdir -p "$TARGET_ROOT"
fi

UPDATED=0
FAILED=0

while IFS=' ' read -r MODE SHA REL_PATH REST; do
	# Skip empty lines and comments
	if [ -z "${MODE:-}" ]; then
		continue
	fi
	case "$MODE" in
		\#*) continue ;;
	esac

	if [ -n "${REST:-}" ] || [ -z "${SHA:-}" ] || [ -z "${REL_PATH:-}" ]; then
		echo "error: invalid manifest line format: '$MODE $SHA $REL_PATH ${REST:-}'" >&2
		FAILED=$((FAILED + 1))
		continue
	fi

	case "$MODE" in
		[0-7][0-7][0-7]|[0-7][0-7][0-7][0-7]) ;;
		*)
			echo "error: invalid mode '$MODE' for $REL_PATH" >&2
			FAILED=$((FAILED + 1))
			continue
			;;
	esac

	case "$SHA" in
		????????????????????????????????????????????????????????????????) ;;
		*)
			echo "error: invalid sha256 '$SHA' for $REL_PATH" >&2
			FAILED=$((FAILED + 1))
			continue
			;;
	esac

	FILE_URL="$BASE_URL/$REL_PATH"
	DOWNLOAD_PATH="$TMP_DIR/download.$$.$UPDATED"
	echo "Fetching payload: $FILE_URL"
	if ! wget -q -O "$DOWNLOAD_PATH" "$FILE_URL"; then
		echo "error: failed to download $FILE_URL" >&2
		FAILED=$((FAILED + 1))
		continue
	fi

	CALC_SHA="$(sha256sum "$DOWNLOAD_PATH" | awk '{print $1}')"
	if [ "$CALC_SHA" != "$SHA" ]; then
		echo "error: checksum mismatch for $REL_PATH" >&2
		echo "  expected: $SHA" >&2
		echo "  actual:   $CALC_SHA" >&2
		FAILED=$((FAILED + 1))
		continue
	fi

	if [ "$DRY_RUN" -eq 1 ]; then
		echo "Validated: $REL_PATH"
		UPDATED=$((UPDATED + 1))
		continue
	fi

	DEST_PATH="$TARGET_ROOT/$REL_PATH"
	DEST_DIR="$(dirname "$DEST_PATH")"
	TMP_DEST="$DEST_PATH.new.$$"

	mkdir -p "$DEST_DIR"
	cp -f "$DOWNLOAD_PATH" "$TMP_DEST"
	chmod "$MODE" "$TMP_DEST"
	mv -f "$TMP_DEST" "$DEST_PATH"
	echo "Installed: $DEST_PATH"
	UPDATED=$((UPDATED + 1))
done < "$MANIFEST_PATH"

if [ "$FAILED" -ne 0 ]; then
	echo "Update failed: $FAILED item(s) had errors" >&2
	exit 1
fi

echo "Update completed: $UPDATED item(s)"

if [ "$DRY_RUN" -eq 0 ] && [ -n "$RESTART_CMD" ]; then
	echo "Running restart command: $RESTART_CMD"
	sh -c "$RESTART_CMD"
fi

exit 0
